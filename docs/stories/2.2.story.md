---
id: "2.2"
title: "Code Modification Undo"
type: "Feature"
priority: "High"
status: "Draft"
assigned_agent: "dev"
epic_id: "2"
sprint_id: ""
created_date: "2025-01-18"
updated_date: "2025-01-18"
estimated_effort: "M"
dependencies: ["Command infrastructure (Story 1.1-1.4)"]
tags: ["undo-redo", "code-editor", "ui"]

user_type: "End User"
component_area: "Code Editor"
technical_complexity: "Medium"
business_value: "High"
---

# Story 2.2: Code Modification Undo

## Story Description

**As a** user, **I want** to undo code changes within nodes **so that** I can experiment with Python code without fear of losing working implementations.

### Context
Building on the completed command infrastructure from Epic 1, this story implements the hybrid undo/redo approach for code editing. The code editor will have its own internal undo/redo during editing sessions, and changes will be committed as atomic operations to the graph's command history when the dialog is accepted.

### Background
The foundation command pattern infrastructure has been established in Epic 1 (Stories 1.1-1.4). This story implements the code editor integration component of the undo/redo system, creating a seamless user experience where code editing feels natural but integrates properly with the overall graph undo history.

## Acceptance Criteria

### AC1: CodeChangeCommand Implementation
**Given** a node with existing code  
**When** user modifies code in the editor dialog and accepts changes  
**Then** a CodeChangeCommand is created tracking full code content before/after modification

### AC2: Code Editor Dialog Integration
**Given** the code editor dialog is open  
**When** user makes code changes and clicks Accept  
**Then** changes are automatically committed as single command to graph history

### AC3: Hybrid Undo Context Management
**Given** code editor dialog is open with changes  
**When** user presses Ctrl+Z within editor  
**Then** editor's internal undo operates without affecting graph history

### AC4: Code State Restoration
**Given** a CodeChangeCommand exists in history  
**When** user undoes the code change  
**Then** exact code state is restored including all content and formatting

### AC5: Large Code Change Efficiency
**Given** user makes substantial code modifications (>1000 characters)  
**When** command is created and executed  
**Then** operation completes efficiently without memory issues

## Tasks / Subtasks

### Implementation Tasks
- [ ] **Task 1**: Create CodeChangeCommand class in commands module (AC: 1, 4)
  - [ ] Subtask 1.1: Implement execute() method for code application
  - [ ] Subtask 1.2: Implement undo() method for code restoration 
  - [ ] Subtask 1.3: Add efficient string handling for large code blocks
  - [ ] Subtask 1.4: Include node reference and code validation

- [ ] **Task 2**: Modify CodeEditorDialog for command integration (AC: 2, 3)
  - [ ] Subtask 2.1: Add graph reference parameter to dialog constructor
  - [ ] Subtask 2.2: Modify accept() method to create and push CodeChangeCommand
  - [ ] Subtask 2.3: Ensure editor's internal undo/redo works independently
  - [ ] Subtask 2.4: Handle dialog cancellation without affecting graph history

- [ ] **Task 3**: Update Node class for code change tracking (AC: 1, 4)
  - [ ] Subtask 3.1: Add set_code() method with proper validation
  - [ ] Subtask 3.2: Ensure pin regeneration works correctly with undo/redo
  - [ ] Subtask 3.3: Maintain node state consistency during code changes

### Testing Tasks
- [ ] **Task 4**: Create unit tests for CodeChangeCommand (AC: 1, 4, 5)
  - [ ] Test code change execution and undo behavior
  - [ ] Test large code block handling and memory efficiency
  - [ ] Test edge cases (empty code, syntax errors, special characters)

- [ ] **Task 5**: Create integration tests for dialog workflow (AC: 2, 3)
  - [ ] Test dialog accept/cancel behavior with command history
  - [ ] Test hybrid undo contexts (editor vs graph)
  - [ ] Test multiple sequential code changes

- [ ] **Task 6**: Add GUI tests for user workflows (AC: 3)
  - [ ] Test Ctrl+Z behavior within code editor
  - [ ] Test undo/redo from main graph after code changes
  - [ ] Test user scenario: edit code, undo, redo, edit again

### Documentation Tasks
- [ ] **Task 7**: Update relevant documentation
  - [ ] Update command system docs with CodeChangeCommand
  - [ ] Add code editor undo behavior to user documentation

## Dev Notes

### Technical Implementation Details

#### Previous Story Insights
Foundation command infrastructure completed in Epic 1 provides:
- Command base class with execute(), undo(), redo() methods [Source: docs/development/fixes/undo-redo-implementation.md#base-command-system]
- CommandHistory class with UI signals and state management [Source: docs/development/fixes/undo-redo-implementation.md#command-history-manager]
- Integration points in NodeGraph for command execution [Source: docs/development/fixes/undo-redo-implementation.md#integration-with-nodegraph]

#### Command Implementation
CodeChangeCommand must implement the established command pattern:
```python
class CodeChangeCommand(Command):
    def __init__(self, node, old_code: str, new_code: str)
    def execute(self) -> bool  # Apply new code to node
    def undo(self) -> bool     # Restore old code to node
```
[Source: docs/development/fixes/undo-redo-implementation.md#change-node-code-command]

#### File Locations & Structure
- **CodeChangeCommand**: `src/commands/node_commands.py` (extend existing file)
- **Dialog modifications**: `src/ui/dialogs/code_editor_dialog.py` 
- **Node modifications**: `src/core/node.py`
- **Test files**: `tests/test_command_system.py`, `tests/gui/test_code_editor_undo.py`

[Source: docs/architecture/source-tree.md#code-editing]

#### Code Editor Integration
The hybrid approach requires:
1. Editor uses QTextEdit built-in undo/redo during editing session
2. Ctrl+Z/Ctrl+Y work only within editor while it has focus  
3. On Accept: Create single ChangeNodeCodeCommand for graph history
4. On Cancel: No changes committed to graph history

[Source: docs/development/fixes/undo-redo-implementation.md#code-editor-integration]

#### Node State Management
Node.set_code() method must:
- Update internal code storage
- Trigger pin regeneration from new function signature
- Maintain node state consistency
- Handle validation and error cases gracefully

[Source: docs/architecture/source-tree.md#node-system]

#### Testing Requirements
Following project testing standards:
- Unit tests in `tests/` directory with fast execution (<5 seconds)
- Integration tests for component interaction
- GUI tests for user workflows using existing test runner
- Test files mirror source structure naming convention

[Source: docs/development/testing-guide.md#test-design-principles]

#### Technical Constraints
- **Windows Platform**: Use Windows-compatible commands only, no Unicode characters
- **PySide6 Framework**: Leverage Qt's built-in text editing undo for efficiency
- **Performance**: Code change operations must complete within 100ms per NFR1
- **Memory**: Large code changes handled efficiently per AC5

[Source: docs/prd.md#non-functional, docs/architecture/coding-standards.md#prohibited-practices]

### Dependencies & Integration Points
- **CommandHistory**: Graph's command history for atomic code commits
- **Node.code property**: Current code storage and validation
- **QTextEdit undo**: Built-in editor undo for typing operations  
- **Dialog lifecycle**: Accept/Cancel handling with proper command integration

### Risk Factors
- **Memory usage**: Large code blocks could impact command history size limits
- **Pin regeneration**: Code changes may break existing connections if signature changes
- **Dialog state**: Ensuring proper cleanup when dialog cancelled vs accepted
- **Performance**: Large code changes must meet 100ms operation requirement

## Testing Strategy

### Unit Testing
- Test coverage target: 80%+
- Focus areas: CodeChangeCommand execute/undo, Node.set_code(), dialog integration
- Mock requirements: Node instances, graph references, dialog interactions

### Integration Testing  
- Integration points: Command history, dialog workflow, node state changes
- Test scenarios: Accept/Cancel workflows, sequential code changes, undo/redo chains

### Manual Testing
- Manual test cases: User code editing workflows, keyboard shortcuts, large code blocks
- User acceptance testing: Natural code editing experience with reliable undo behavior

## Definition of Done

- [ ] All tasks and subtasks completed
- [ ] All acceptance criteria verified
- [ ] Unit tests written and passing (80%+ coverage)
- [ ] Integration tests passing  
- [ ] Code review completed
- [ ] Documentation updated
- [ ] Manual testing completed
- [ ] No regression in existing undo/redo functionality
- [ ] Performance requirements met (100ms operation time)
- [ ] Memory efficiency validated for large code changes

## Dev Agent Record

### Agent Model Used
[Empty initially - filled by dev agent]

### Debug Log References  
[Empty initially - dev agent adds references to debug sessions, errors encountered]

### Completion Notes
[Empty initially - dev agent documents implementation decisions, deviations from plan]

### File List
[Empty initially - dev agent lists all files created, modified, or deleted]
- **Created**: 
- **Modified**:
- **Deleted**:

### Change Log
[Empty initially - dev agent documents significant changes made during implementation]
- **[Date]**: [Description of change and rationale]

### Implementation Deviations
[Empty initially - dev agent notes any deviations from original plan with justification]

### Lessons Learned
[Empty initially - dev agent documents insights for future stories]