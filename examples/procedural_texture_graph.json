{
    "requirements": [
        "numpy",
        "Pillow"
    ],
    "nodes": [
        {
            "uuid": "noise-params",
            "title": "1. Noise Parameters",
            "pos": [ 50, 200 ],
            "code": "from typing import Tuple\n\n@node_entry\ndef get_noise_parameters(seed: int, scale: float, octaves: int, persistence: float, lacunarity: float) -> Tuple[int, float, int, float, float]:\n    return seed, scale, octaves, persistence, lacunarity",
            "gui_code": "from PySide6.QtWidgets import QLabel, QSpinBox, QDoubleSpinBox\n\nlayout.addWidget(QLabel('Seed:', parent))\nwidgets['seed'] = QSpinBox(parent)\nwidgets['seed'].setRange(0, 9999)\nwidgets['seed'].setValue(42)\nlayout.addWidget(widgets['seed'])\n\nlayout.addWidget(QLabel('Scale:', parent))\nwidgets['scale'] = QDoubleSpinBox(parent)\nwidgets['scale'].setRange(10.0, 200.0)\nwidgets['scale'].setValue(50.0)\nlayout.addWidget(widgets['scale'])\n\nlayout.addWidget(QLabel('Octaves:', parent))\nwidgets['octaves'] = QSpinBox(parent)\nwidgets['octaves'].setRange(1, 8)\nwidgets['octaves'].setValue(4)\nlayout.addWidget(widgets['octaves'])\n\nlayout.addWidget(QLabel('Persistence:', parent))\nwidgets['persistence'] = QDoubleSpinBox(parent)\nwidgets['persistence'].setRange(0.1, 1.0)\nwidgets['persistence'].setValue(0.5)\nwidgets['persistence'].setSingleStep(0.1)\nlayout.addWidget(widgets['persistence'])\n\nlayout.addWidget(QLabel('Lacunarity:', parent))\nwidgets['lacunarity'] = QDoubleSpinBox(parent)\nwidgets['lacunarity'].setRange(1.0, 4.0)\nwidgets['lacunarity'].setValue(2.0)\nwidgets['lacunarity'].setSingleStep(0.1)\nlayout.addWidget(widgets['lacunarity'])",
            "gui_get_values_code": "def get_values(widgets):\n    return {\n        'seed': widgets['seed'].value(),\n        'scale': widgets['scale'].value(),\n        'octaves': widgets['octaves'].value(),\n        'persistence': widgets['persistence'].value(),\n        'lacunarity': widgets['lacunarity'].value()\n    }\n\ndef set_initial_state(widgets, state):\n    if 'seed' in state: widgets['seed'].setValue(state['seed'])\n    if 'scale' in state: widgets['scale'].setValue(state['scale'])\n    if 'octaves' in state: widgets['octaves'].setValue(state['octaves'])\n    if 'persistence' in state: widgets['persistence'].setValue(state['persistence'])\n    if 'lacunarity' in state: widgets['lacunarity'].setValue(state['lacunarity'])"
        },
        {
            "uuid": "color-palette",
            "title": "2. Color Palette",
            "pos": [ 50, 550 ],
            "code": "@node_entry\ndef get_color_palette(color1: str, color2: str, color3: str) -> str:\n    # Pass colors as a delimited string\n    return f'{color1};{color2};{color3}'",
            "gui_code": "from PySide6.QtWidgets import QLabel, QPushButton, QColorDialog\nfrom PySide6.QtGui import QColor\n\n# Helper to update button color\ndef update_color(button, color_str):\n    button.setStyleSheet(f'background-color: {color_str};')\n\n# --- BUG FIX: Use lambdas to correctly capture scope for signal handlers ---\nlayout.addWidget(QLabel('Gradient Colors:', parent))\n\n# Color 1\nbtn1 = QPushButton('#0D3B66', parent)\nbtn1.clicked.connect(lambda: (lambda b=btn1: (color := QColorDialog.getColor(QColor(b.text()))).isValid() and (b.setText(color.name()), update_color(b, color.name())))())\nupdate_color(btn1, '#0D3B66')\nwidgets['color1_button'] = btn1\nlayout.addWidget(btn1)\n\n# Color 2\nbtn2 = QPushButton('#FAF0CA', parent)\nbtn2.clicked.connect(lambda: (lambda b=btn2: (color := QColorDialog.getColor(QColor(b.text()))).isValid() and (b.setText(color.name()), update_color(b, color.name())))())\nupdate_color(btn2, '#FAF0CA')\nwidgets['color2_button'] = btn2\nlayout.addWidget(btn2)\n\n# Color 3\nbtn3 = QPushButton('#F95738', parent)\nbtn3.clicked.connect(lambda: (lambda b=btn3: (color := QColorDialog.getColor(QColor(b.text()))).isValid() and (b.setText(color.name()), update_color(b, color.name())))())\nupdate_color(btn3, '#F95738')\nwidgets['color3_button'] = btn3\nlayout.addWidget(btn3)",
            "gui_get_values_code": "def get_values(widgets):\n    return {\n        'color1': widgets['color1_button'].text(),\n        'color2': widgets['color2_button'].text(),\n        'color3': widgets['color3_button'].text()\n    }\n\ndef set_initial_state(widgets, state):\n    # Helper to update button color\n    def update_color(button, color_str):\n        button.setStyleSheet(f'background-color: {color_str};')\n    if 'color1' in state: \n        widgets['color1_button'].setText(state['color1'])\n        update_color(widgets['color1_button'], state['color1'])\n    if 'color2' in state: \n        widgets['color2_button'].setText(state['color2'])\n        update_color(widgets['color2_button'], state['color2'])\n    if 'color3' in state: \n        widgets['color3_button'].setText(state['color3'])\n        update_color(widgets['color3_button'], state['color3'])"
        },
        {
            "uuid": "noise-generator",
            "title": "3. Generate Noise Map",
            "pos": [ 450, 200 ],
            "code": "import numpy as np\nimport json\n\n# Helper function for linear interpolation\ndef lerp(a, b, x):\n    return a + x * (b - a)\n\n# Perlin noise implementation (for portability)\ndef perlin(x, y, seed=0):\n    np.random.seed(seed)\n    p = np.arange(256, dtype=int)\n    np.random.shuffle(p)\n    p = np.stack([p, p]).flatten()\n    xi, yi = x.astype(int), y.astype(int)\n    xf, yf = x - xi, y - yi\n    u, v = xf * xf * xf * (xf * (xf * 6 - 15) + 10), yf * yf * yf * (yf * (yf * 6 - 15) + 10)\n    # This is a simplified noise function for demonstration\n    n00 = np.sin(xi) + np.cos(yi)\n    n10 = np.sin(xi+1) + np.cos(yi)\n    n01 = np.sin(xi) + np.cos(yi+1)\n    n11 = np.sin(xi+1) + np.cos(yi+1)\n    x1 = lerp(n00, n10, u)\n    x2 = lerp(n01, n11, u)\n    return lerp(x1, x2, v)\n\n@node_entry\ndef generate_noise(seed: int, scale: float, octaves: int, persistence: float, lacunarity: float) -> str:\n    width, height = 256, 256\n    shape = (width, height)\n    \n    noise_map = np.zeros(shape)\n    frequency = 1\n    amplitude = 1\n    \n    for i in range(octaves):\n        lin_x = np.linspace(0, width / scale * frequency, width, endpoint=False)\n        lin_y = np.linspace(0, height / scale * frequency, height, endpoint=False)\n        x, y = np.meshgrid(lin_x, lin_y)\n        noise_map += perlin(x, y, seed + i) * amplitude\n        \n        amplitude *= persistence\n        frequency *= lacunarity\n\n    # Normalize to 0-1 range\n    if np.max(noise_map) != np.min(noise_map):\n        noise_map = (noise_map - np.min(noise_map)) / (np.max(noise_map) - np.min(noise_map))\n    \n    # Return as a JSON string of a list\n    return json.dumps(noise_map.tolist())",
            "colors": { "title": "#006A4E", "body": "#004B38" }
        },
        {
            "uuid": "colorize-node",
            "title": "4. Colorize Noise Map",
            "pos": [ 850, 350 ],
            "code": "import numpy as np\nfrom PIL import Image\nimport json\nimport base64\nimport io\n\n@node_entry\ndef colorize_noise(noise_map_json: str, palette_str: str) -> str:\n    try:\n        noise_map = np.array(json.loads(noise_map_json))\n        colors_hex = palette_str.split(';')\n        colors_rgb = [tuple(int(h.lstrip('#')[i:i+2], 16) for i in (0, 2, 4)) for h in colors_hex]\n\n        width, height = noise_map.shape\n        color_image = np.zeros((height, width, 3), dtype=np.uint8)\n\n        # Create a simple linear gradient from the colors\n        for i in range(width):\n            for j in range(height):\n                val = noise_map[i, j]\n                if val < 0.5:\n                    t = val * 2\n                    color = (int((1-t)*colors_rgb[0][c] + t*colors_rgb[1][c]) for c in range(3))\n                else:\n                    t = (val - 0.5) * 2\n                    color = (int((1-t)*colors_rgb[1][c] + t*colors_rgb[2][c]) for c in range(3))\n                color_image[j, i] = tuple(color)\n\n        img = Image.fromarray(color_image, 'RGB')\n        \n        # Convert image to base64 string to pass to the GUI without saving a file\n        buffered = io.BytesIO()\n        img.save(buffered, format=\"PNG\")\n        img_str = base64.b64encode(buffered.getvalue()).decode('utf-8')\n        return img_str\n    except Exception as e:\n        return f'ERROR: {e}'",
            "colors": { "title": "#5C2A9D", "body": "#3C1D63" }
        },
        {
            "uuid": "image-preview",
            "title": "5. Texture Preview",
            "pos": [ 1250, 350 ],
            "code": "@node_entry\ndef show_image(image_base64: str) -> str:\n    # Pass the data through for the GUI logic to use\n    return image_base64",
            "gui_code": "from PySide6.QtWidgets import QLabel\nfrom PySide6.QtGui import QPixmap\nfrom PySide6.QtCore import Qt\n\nwidgets['image_label'] = QLabel('Execute graph to generate texture...', parent)\nwidgets['image_label'].setMinimumSize(256, 256)\nwidgets['image_label'].setAlignment(Qt.AlignCenter)\nwidgets['image_label'].setStyleSheet('border: 1px solid #555;')\nlayout.addWidget(widgets['image_label'])",
            "gui_get_values_code": "import base64\n\ndef get_values(widgets):\n    return {}\n\ndef set_values(widgets, outputs):\n    from PySide6.QtGui import QPixmap\n    from PySide6.QtCore import Qt\n    img_str = outputs.get('output_1')\n    if img_str and not img_str.startswith('ERROR'):\n        try:\n            img_data = base64.b64decode(img_str)\n            pixmap = QPixmap()\n            pixmap.loadFromData(img_data)\n            if not pixmap.isNull():\n                widgets['image_label'].setPixmap(pixmap)\n            else:\n                widgets['image_label'].setText('Error: Could not load image data')\n        except Exception as e:\n            widgets['image_label'].setText(f'Error decoding image:\\n{e}')\n    else:\n        widgets['image_label'].setText(f'Execution failed:\\n{img_str}')"
        }
    ],
    "connections": [
        { "start_node_uuid": "noise-params", "start_pin_name": "output_1", "end_node_uuid": "noise-generator", "end_pin_name": "seed" },
        { "start_node_uuid": "noise-params", "start_pin_name": "output_2", "end_node_uuid": "noise-generator", "end_pin_name": "scale" },
        { "start_node_uuid": "noise-params", "start_pin_name": "output_3", "end_node_uuid": "noise-generator", "end_pin_name": "octaves" },
        { "start_node_uuid": "noise-params", "start_pin_name": "output_4", "end_node_uuid": "noise-generator", "end_pin_name": "persistence" },
        { "start_node_uuid": "noise-params", "start_pin_name": "output_5", "end_node_uuid": "noise-generator", "end_pin_name": "lacunarity" },
        { "start_node_uuid": "noise-generator", "start_pin_name": "output_1", "end_node_uuid": "colorize-node", "end_pin_name": "noise_map_json" },
        { "start_node_uuid": "color-palette", "start_pin_name": "output_1", "end_node_uuid": "colorize-node", "end_pin_name": "palette_str" },
        { "start_node_uuid": "colorize-node", "start_pin_name": "output_1", "end_node_uuid": "image-preview", "end_pin_name": "image_base64" }
    ]
}
