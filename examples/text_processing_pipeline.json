{
    "nodes": [
        {
            "uuid": "text-input",
            "title": "Text Input Source",
            "pos": [100, 200],
            "size": [300, 250],
            "code": "@node_entry\ndef provide_text(input_text: str, source_type: str) -> str:\n    if source_type == \"Manual\":\n        result = input_text\n    elif source_type == \"Lorem Ipsum\":\n        result = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.\"\n    elif source_type == \"Sample Article\":\n        result = \"Artificial Intelligence has revolutionized many industries. Machine learning algorithms can process vast amounts of data quickly. Natural language processing enables computers to understand human text. Deep learning models achieve remarkable accuracy in image recognition. The future of AI looks promising with continued research and development.\"\n    else:  # Technical Text\n        result = \"Python is a high-level programming language. It supports object-oriented programming paradigms. The syntax is designed to be readable and concise. Libraries like NumPy and Pandas facilitate data analysis. Django and Flask are popular web frameworks. Python's versatility makes it suitable for various applications.\"\n    \n    print(f\"Text source: {source_type}\")\n    print(f\"Text length: {len(result)} characters\")\n    print(f\"Preview: {result[:100]}...\")\n    \n    return result",
            "gui_code": "from PySide6.QtWidgets import QLabel, QTextEdit, QComboBox, QPushButton\n\nlayout.addWidget(QLabel('Text Source:', parent))\nwidgets['source_type'] = QComboBox(parent)\nwidgets['source_type'].addItems(['Manual', 'Lorem Ipsum', 'Sample Article', 'Technical Text'])\nlayout.addWidget(widgets['source_type'])\n\nlayout.addWidget(QLabel('Enter your text (for Manual mode):', parent))\nwidgets['input_text'] = QTextEdit(parent)\nwidgets['input_text'].setMinimumHeight(120)\nwidgets['input_text'].setPlaceholderText('Type your text here...')\nlayout.addWidget(widgets['input_text'])\n\nwidgets['process_btn'] = QPushButton('Process Text', parent)\nlayout.addWidget(widgets['process_btn'])",
            "gui_get_values_code": "def get_values(widgets):\n    return {\n        'input_text': widgets['input_text'].toPlainText(),\n        'source_type': widgets['source_type'].currentText()\n    }\n\ndef set_initial_state(widgets, state):\n    widgets['input_text'].setPlainText(state.get('input_text', ''))\n    widgets['source_type'].setCurrentText(state.get('source_type', 'Manual'))",
            "gui_state": {
                "input_text": "",
                "source_type": "Manual"
            },
            "colors": {
                "title": "#007bff",
                "body": "#0056b3"
            }
        },
        {
            "uuid": "text-cleaner",
            "title": "Text Cleaner & Normalizer",
            "pos": [470, 150],
            "size": [280, 200],
            "code": "import re\nimport string\n\n@node_entry\ndef clean_text(text: str, remove_punctuation: bool, convert_lowercase: bool, remove_numbers: bool) -> str:\n    cleaned = text\n    \n    # Remove extra whitespace\n    cleaned = re.sub(r'\\s+', ' ', cleaned.strip())\n    \n    # Convert to lowercase\n    if convert_lowercase:\n        cleaned = cleaned.lower()\n    \n    # Remove punctuation\n    if remove_punctuation:\n        cleaned = cleaned.translate(str.maketrans('', '', string.punctuation))\n    \n    # Remove numbers\n    if remove_numbers:\n        cleaned = re.sub(r'\\d+', '', cleaned)\n    \n    # Clean up extra spaces again\n    cleaned = re.sub(r'\\s+', ' ', cleaned.strip())\n    \n    print(f\"Original length: {len(text)}\")\n    print(f\"Cleaned length: {len(cleaned)}\")\n    print(f\"Cleaning options: Lowercase={convert_lowercase}, No punctuation={remove_punctuation}, No numbers={remove_numbers}\")\n    \n    return cleaned",
            "gui_code": "from PySide6.QtWidgets import QLabel, QCheckBox, QPushButton\n\nwidgets['remove_punctuation'] = QCheckBox('Remove Punctuation', parent)\nwidgets['remove_punctuation'].setChecked(False)\nlayout.addWidget(widgets['remove_punctuation'])\n\nwidgets['convert_lowercase'] = QCheckBox('Convert to Lowercase', parent)\nwidgets['convert_lowercase'].setChecked(True)\nlayout.addWidget(widgets['convert_lowercase'])\n\nwidgets['remove_numbers'] = QCheckBox('Remove Numbers', parent)\nwidgets['remove_numbers'].setChecked(False)\nlayout.addWidget(widgets['remove_numbers'])\n\nwidgets['clean_btn'] = QPushButton('Clean Text', parent)\nlayout.addWidget(widgets['clean_btn'])",
            "gui_get_values_code": "def get_values(widgets):\n    return {\n        'remove_punctuation': widgets['remove_punctuation'].isChecked(),\n        'convert_lowercase': widgets['convert_lowercase'].isChecked(),\n        'remove_numbers': widgets['remove_numbers'].isChecked()\n    }\n\ndef set_initial_state(widgets, state):\n    widgets['remove_punctuation'].setChecked(state.get('remove_punctuation', False))\n    widgets['convert_lowercase'].setChecked(state.get('convert_lowercase', True))\n    widgets['remove_numbers'].setChecked(state.get('remove_numbers', False))",
            "gui_state": {
                "remove_punctuation": false,
                "convert_lowercase": true,
                "remove_numbers": false
            },
            "colors": {
                "title": "#28a745",
                "body": "#1e7e34"
            }
        },
        {
            "uuid": "text-analyzer",
            "title": "Text Statistics Analyzer",
            "pos": [470, 400],
            "size": [280, 250],
            "code": "import re\nfrom typing import Tuple\nfrom collections import Counter\n\n@node_entry\ndef analyze_text(text: str) -> Tuple[int, int, int, int, float, str]:\n    # Basic counts\n    char_count = len(text)\n    word_count = len(text.split())\n    sentence_count = len(re.findall(r'[.!?]+', text))\n    paragraph_count = len([p for p in text.split('\\n\\n') if p.strip()])\n    \n    # Average word length\n    words = text.split()\n    avg_word_length = sum(len(word.strip('.,!?;:')) for word in words) / len(words) if words else 0\n    \n    # Most common words (top 5)\n    word_freq = Counter(word.lower().strip('.,!?;:') for word in words if len(word) > 2)\n    top_words = ', '.join([f\"{word}({count})\" for word, count in word_freq.most_common(5)])\n    \n    print(\"\\n=== TEXT ANALYSIS ===\")\n    print(f\"Characters: {char_count}\")\n    print(f\"Words: {word_count}\")\n    print(f\"Sentences: {sentence_count}\")\n    print(f\"Paragraphs: {paragraph_count}\")\n    print(f\"Average word length: {avg_word_length:.1f}\")\n    print(f\"Most frequent words: {top_words}\")\n    \n    return char_count, word_count, sentence_count, paragraph_count, round(avg_word_length, 1), top_words",
            "gui_code": "",
            "gui_get_values_code": "",
            "gui_state": {},
            "colors": {
                "title": "#fd7e14",
                "body": "#e8590c"
            }
        },
        {
            "uuid": "keyword-extractor",
            "title": "Keyword & Phrase Extractor",
            "pos": [820, 200],
            "size": [300, 250],
            "code": "import re\nfrom typing import Tuple, List\nfrom collections import Counter\n\n@node_entry\ndef extract_keywords(text: str, min_word_length: int) -> Tuple[List[str], List[str], List[str]]:\n    # Common stop words\n    stop_words = {'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'this', 'that', 'these', 'those'}\n    \n    # Extract words\n    words = re.findall(r'\\b[a-zA-Z]+\\b', text.lower())\n    \n    # Filter keywords (non-stop words, minimum length)\n    keywords = [word for word in words if word not in stop_words and len(word) >= min_word_length]\n    keyword_freq = Counter(keywords)\n    top_keywords = [word for word, count in keyword_freq.most_common(10)]\n    \n    # Extract potential phrases (2-3 word combinations)\n    phrase_pattern = r'\\b(?:[a-zA-Z]+\\s+){1,2}[a-zA-Z]+\\b'\n    phrases = re.findall(phrase_pattern, text.lower())\n    filtered_phrases = []\n    for phrase in phrases:\n        words_in_phrase = phrase.split()\n        if len(words_in_phrase) >= 2 and not any(word in stop_words for word in words_in_phrase[:2]):\n            filtered_phrases.append(phrase.strip())\n    \n    phrase_freq = Counter(filtered_phrases)\n    top_phrases = [phrase for phrase, count in phrase_freq.most_common(5)]\n    \n    # Extract capitalized words (potential proper nouns)\n    proper_nouns = list(set(re.findall(r'\\b[A-Z][a-zA-Z]+\\b', text)))\n    proper_nouns = [noun for noun in proper_nouns if len(noun) > 2][:10]\n    \n    print(\"\\n=== KEYWORD EXTRACTION ===\")\n    print(f\"Top keywords: {', '.join(top_keywords[:5])}\")\n    print(f\"Key phrases: {', '.join(top_phrases[:3])}\")\n    print(f\"Proper nouns: {', '.join(proper_nouns[:5])}\")\n    \n    return top_keywords, top_phrases, proper_nouns",
            "gui_code": "from PySide6.QtWidgets import QLabel, QSpinBox, QPushButton\n\nlayout.addWidget(QLabel('Minimum Keyword Length:', parent))\nwidgets['min_word_length'] = QSpinBox(parent)\nwidgets['min_word_length'].setRange(3, 10)\nwidgets['min_word_length'].setValue(4)\nlayout.addWidget(widgets['min_word_length'])\n\nwidgets['extract_btn'] = QPushButton('Extract Keywords', parent)\nlayout.addWidget(widgets['extract_btn'])",
            "gui_get_values_code": "def get_values(widgets):\n    return {\n        'min_word_length': widgets['min_word_length'].value()\n    }\n\ndef set_initial_state(widgets, state):\n    widgets['min_word_length'].setValue(state.get('min_word_length', 4))",
            "gui_state": {
                "min_word_length": 4
            },
            "colors": {
                "title": "#6f42c1",
                "body": "#563d7c"
            }
        },
        {
            "uuid": "report-generator",
            "title": "Processing Report Generator",
            "pos": [1190, 250],
            "size": [350, 300],
            "code": "from typing import List\n\n@node_entry\ndef generate_report(original_text: str, cleaned_text: str, char_count: int, word_count: int, sentence_count: int, paragraph_count: int, avg_word_length: float, top_words: str, keywords: List[str], phrases: List[str], proper_nouns: List[str]) -> str:\n    report = \"\\n\" + \"=\"*60 + \"\\n\"\n    report += \"               TEXT PROCESSING REPORT\\n\"\n    report += \"=\"*60 + \"\\n\\n\"\n    \n    # Text Overview\n    report += \"📊 TEXT OVERVIEW\\n\"\n    report += f\"   • Characters: {char_count:,}\\n\"\n    report += f\"   • Words: {word_count:,}\\n\"\n    report += f\"   • Sentences: {sentence_count}\\n\"\n    report += f\"   • Paragraphs: {paragraph_count}\\n\"\n    report += f\"   • Average word length: {avg_word_length} characters\\n\\n\"\n    \n    # Processing Summary\n    report += \"🔧 PROCESSING SUMMARY\\n\"\n    original_words = len(original_text.split())\n    cleaned_words = len(cleaned_text.split())\n    report += f\"   • Original text: {len(original_text)} characters, {original_words} words\\n\"\n    report += f\"   • Cleaned text: {len(cleaned_text)} characters, {cleaned_words} words\\n\"\n    report += f\"   • Reduction: {len(original_text) - len(cleaned_text)} characters\\n\\n\"\n    \n    # Frequency Analysis\n    report += \"📈 FREQUENCY ANALYSIS\\n\"\n    report += f\"   • Most common words: {top_words}\\n\\n\"\n    \n    # Keywords and Phrases\n    report += \"🔍 EXTRACTED KEYWORDS\\n\"\n    report += f\"   • Key terms: {', '.join(keywords[:8])}\\n\"\n    if phrases:\n        report += f\"   • Key phrases: {', '.join(phrases[:4])}\\n\"\n    if proper_nouns:\n        report += f\"   • Proper nouns: {', '.join(proper_nouns[:6])}\\n\"\n    report += \"\\n\"\n    \n    # Text Sample\n    report += \"📝 PROCESSED TEXT SAMPLE\\n\"\n    sample = cleaned_text[:200] + \"...\" if len(cleaned_text) > 200 else cleaned_text\n    report += f\"   {sample}\\n\\n\"\n    \n    report += \"=\"*60\n    \n    print(report)\n    return report",
            "gui_code": "from PySide6.QtWidgets import QLabel, QTextEdit, QPushButton\nfrom PySide6.QtCore import Qt\nfrom PySide6.QtGui import QFont\n\ntitle_label = QLabel('Text Processing Report', parent)\ntitle_font = QFont()\ntitle_font.setPointSize(14)\ntitle_font.setBold(True)\ntitle_label.setFont(title_font)\nlayout.addWidget(title_label)\n\nwidgets['report_display'] = QTextEdit(parent)\nwidgets['report_display'].setMinimumHeight(200)\nwidgets['report_display'].setReadOnly(True)\nwidgets['report_display'].setPlainText('Process text to generate report...')\nfont = QFont('Courier New', 9)\nwidgets['report_display'].setFont(font)\nlayout.addWidget(widgets['report_display'])\n\nwidgets['save_report_btn'] = QPushButton('Save Report', parent)\nlayout.addWidget(widgets['save_report_btn'])\n\nwidgets['new_analysis_btn'] = QPushButton('New Analysis', parent)\nlayout.addWidget(widgets['new_analysis_btn'])",
            "gui_get_values_code": "def get_values(widgets):\n    return {}\n\ndef set_values(widgets, outputs):\n    report = outputs.get('output_1', 'No report data')\n    widgets['report_display'].setPlainText(report)",
            "gui_state": {},
            "colors": {
                "title": "#17a2b8",
                "body": "#117a8b"
            }
        }
    ],
    "connections": [
        {
            "start_node_uuid": "text-input",
            "start_pin_name": "exec_out",
            "end_node_uuid": "text-cleaner",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "text-input",
            "start_pin_name": "output_1",
            "end_node_uuid": "text-cleaner",
            "end_pin_name": "text"
        },
        {
            "start_node_uuid": "text-cleaner",
            "start_pin_name": "exec_out",
            "end_node_uuid": "text-analyzer",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "text-cleaner",
            "start_pin_name": "output_1",
            "end_node_uuid": "text-analyzer",
            "end_pin_name": "text"
        },
        {
            "start_node_uuid": "text-cleaner",
            "start_pin_name": "exec_out",
            "end_node_uuid": "keyword-extractor",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "text-cleaner",
            "start_pin_name": "output_1",
            "end_node_uuid": "keyword-extractor",
            "end_pin_name": "text"
        },
        {
            "start_node_uuid": "text-analyzer",
            "start_pin_name": "exec_out",
            "end_node_uuid": "report-generator",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "keyword-extractor",
            "start_pin_name": "exec_out",
            "end_node_uuid": "report-generator",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "text-input",
            "start_pin_name": "output_1",
            "end_node_uuid": "report-generator",
            "end_pin_name": "original_text"
        },
        {
            "start_node_uuid": "text-cleaner",
            "start_pin_name": "output_1",
            "end_node_uuid": "report-generator",
            "end_pin_name": "cleaned_text"
        },
        {
            "start_node_uuid": "text-analyzer",
            "start_pin_name": "output_1",
            "end_node_uuid": "report-generator",
            "end_pin_name": "char_count"
        },
        {
            "start_node_uuid": "text-analyzer",
            "start_pin_name": "output_2",
            "end_node_uuid": "report-generator",
            "end_pin_name": "word_count"
        },
        {
            "start_node_uuid": "text-analyzer",
            "start_pin_name": "output_3",
            "end_node_uuid": "report-generator",
            "end_pin_name": "sentence_count"
        },
        {
            "start_node_uuid": "text-analyzer",
            "start_pin_name": "output_4",
            "end_node_uuid": "report-generator",
            "end_pin_name": "paragraph_count"
        },
        {
            "start_node_uuid": "text-analyzer",
            "start_pin_name": "output_5",
            "end_node_uuid": "report-generator",
            "end_pin_name": "avg_word_length"
        },
        {
            "start_node_uuid": "text-analyzer",
            "start_pin_name": "output_6",
            "end_node_uuid": "report-generator",
            "end_pin_name": "top_words"
        },
        {
            "start_node_uuid": "keyword-extractor",
            "start_pin_name": "output_1",
            "end_node_uuid": "report-generator",
            "end_pin_name": "keywords"
        },
        {
            "start_node_uuid": "keyword-extractor",
            "start_pin_name": "output_2",
            "end_node_uuid": "report-generator",
            "end_pin_name": "phrases"
        },
        {
            "start_node_uuid": "keyword-extractor",
            "start_pin_name": "output_3",
            "end_node_uuid": "report-generator",
            "end_pin_name": "proper_nouns"
        }
    ],
    "requirements": []
}