{
    "nodes": [
        {
            "uuid": "meta-title",
            "title": "Project Title",
            "pos": [ 50, 100 ],
            "code": "@node_entry\ndef get_title() -> str:\n    return 'PySide6 Advanced Node Editor'"
        },
        {
            "uuid": "meta-repo-url",
            "title": "Repo URL",
            "pos": [ 50, 250 ],
            "code": "@node_entry\ndef get_repo_url() -> str:\n    return 'https://github.com/bhowiebkr/nodes'"
        },
        {
            "uuid": "meta-features",
            "title": "Feature List",
            "pos": [ 50, 400 ],
            "code": "@node_entry\ndef get_features() -> str:\n    # Workaround: Return a delimited string instead of a list\n    features = [\n        'Dynamic Node Generation via Decorators',\n        'Blueprint-Style Navigation and Controls',\n        'Data-Driven Execution Engine',\n        'Mini-IDE with Syntax Highlighting'\n    ]\n    return ';;;'.join(features)"
        },
        {
            "uuid": "meta-version",
            "title": "Version Number",
            "pos": [ 50, 550 ],
            "code": "@node_entry\ndef get_version() -> float:\n    return 1.3"
        },
        {
            "uuid": "meta-include-license",
            "title": "Include License Section",
            "pos": [ 50, 700 ],
            "code": "@node_entry\ndef should_include_license() -> bool:\n    return True"
        },
        {
            "uuid": "format-header",
            "title": "Format Header",
            "pos": [ 350, 175 ],
            "code": "@node_entry\ndef format_header(title: str, repo_url: str, version: float) -> str:\n    return f'# {title} (v{version})\\n\\n[View on GitHub]({repo_url})'"
        },
        {
            "uuid": "format-features",
            "title": "Format Features Section",
            "pos": [ 350, 400 ],
            "code": "@node_entry\ndef format_features(features_str: str) -> str:\n    # Workaround: Split the delimited string back into a list\n    features = features_str.split(';;;')\n    if not features or not features[0]:\n        return ''\n    feature_list = '\\n'.join([f'* {feature}' for feature in features])\n    return f'## Features\\n\\n{feature_list}'"
        },
        {
            "uuid": "format-license",
            "title": "Format License Section",
            "pos": [ 350, 700 ],
            "code": "@node_entry\ndef format_license(include: bool) -> str:\n    if include:\n        return '## License\\n\\nThis project is licensed under the MIT License.'\n    return ''"
        },
        {
            "uuid": "scan-directory",
            "title": "Scan Project Directory",
            "pos": [ 650, 550 ],
            "code": "import os\n\n@node_entry\ndef scan_project_files() -> str:\n    # Workaround: Return a delimited string of filenames\n    try:\n        files = [f for f in os.listdir('.') if os.path.isfile(f)]\n        if 'generated_readme.md' in files:\n            files.remove('generated_readme.md')\n        return ';;;'.join(sorted(files))\n    except Exception as e:\n        print(f'Error scanning directory: {e}')\n        return ''"
        },
        {
            "uuid": "analyze-files",
            "title": "Analyze File Types",
            "pos": [ 950, 550 ],
            "code": "from typing import Tuple\n\n@node_entry\ndef analyze_files(files_str: str) -> Tuple[int, int]:\n    # This node correctly creates two output pins\n    files = files_str.split(';;;')\n    if not files or not files[0]:\n        return 0, 0\n    py_count = sum(1 for f in files if f.endswith('.py'))\n    qss_count = sum(1 for f in files if f.endswith('.qss'))\n    return py_count, qss_count"
        },
        {
            "uuid": "format-structure",
            "title": "Format Project Structure",
            "pos": [ 1250, 550 ],
            "code": "@node_entry\ndef format_structure(py_files: int, qss_files: int, file_list_str: str) -> str:\n    files = file_list_str.split(';;;')\n    if not files or not files[0]:\n        return ''\n    structure_intro = f'The project contains {py_files} Python files and {qss_files} stylesheet(s).' \n    file_md_list = '\\n'.join([f'- `{f}`' for f in files])\n    return f'## Project Structure\\n\\n{structure_intro}\\n\\n{file_md_list}'"
        },
        {
            "uuid": "assemble-readme",
            "title": "Assemble README",
            "pos": [ 1550, 400 ],
            "code": "@node_entry\ndef assemble_readme(header: str, features: str, structure: str, license_info: str) -> str:\n    sections = [header, features, structure, license_info]\n    non_empty_sections = [s for s in sections if s]\n    return '\\n\\n---\\n\\n'.join(non_empty_sections)"
        },
        {
            "uuid": "write-file",
            "title": "Write Markdown File",
            "pos": [ 1850, 400 ],
            "code": "@node_entry\ndef write_readme_file(content: str):\n    filename = 'generated_readme.md'\n    try:\n        with open(filename, 'w') as f:\n            f.write(content)\n        print(f'Successfully wrote README to {filename}')\n    except Exception as e:\n        print(f'Error writing file: {e}')"
        }
    ],
    "connections": [
        { "start_node_uuid": "meta-title", "start_pin_name": "output_1", "end_node_uuid": "format-header", "end_pin_name": "title" },
        { "start_node_uuid": "meta-repo-url", "start_pin_name": "output_1", "end_node_uuid": "format-header", "end_pin_name": "repo_url" },
        { "start_node_uuid": "meta-version", "start_pin_name": "output_1", "end_node_uuid": "format-header", "end_pin_name": "version" },
        { "start_node_uuid": "meta-features", "start_pin_name": "output_1", "end_node_uuid": "format-features", "end_pin_name": "features_str" },
        { "start_node_uuid": "meta-include-license", "start_pin_name": "output_1", "end_node_uuid": "format-license", "end_pin_name": "include" },
        { "start_node_uuid": "scan-directory", "start_pin_name": "output_1", "end_node_uuid": "analyze-files", "end_pin_name": "files_str" },
        { "start_node_uuid": "analyze-files", "start_pin_name": "output_1", "end_node_uuid": "format-structure", "end_pin_name": "py_files" },
        { "start_node_uuid": "analyze-files", "start_pin_name": "output_2", "end_node_uuid": "format-structure", "end_pin_name": "qss_files" },
        { "start_node_uuid": "scan-directory", "start_pin_name": "output_1", "end_node_uuid": "format-structure", "end_pin_name": "file_list_str" },
        { "start_node_uuid": "format-header", "start_pin_name": "output_1", "end_node_uuid": "assemble-readme", "end_pin_name": "header" },
        { "start_node_uuid": "format-features", "start_pin_name": "output_1", "end_node_uuid": "assemble-readme", "end_pin_name": "features" },
        { "start_node_uuid": "format-structure", "start_pin_name": "output_1", "end_node_uuid": "assemble-readme", "end_pin_name": "structure" },
        { "start_node_uuid": "format-license", "start_pin_name": "output_1", "end_node_uuid": "assemble-readme", "end_pin_name": "license_info" },
        { "start_node_uuid": "assemble-readme", "start_pin_name": "output_1", "end_node_uuid": "write-file", "end_pin_name": "content" }
    ]
}
