{
    "nodes": [
        {
            "uuid": "content-creator",
            "title": "Content Creator & Editor",
            "pos": [100, 200],
            "size": [320, 300],
            "code": "import datetime\nfrom typing import Tuple\n\n@node_entry\ndef create_content(content_text: str, platform: str, content_type: str, hashtags: str, schedule_time: str) -> Tuple[str, str, str, str, str]:\n    # Process hashtags\n    processed_hashtags = [tag.strip() for tag in hashtags.split(',') if tag.strip()]\n    if not any(tag.startswith('#') for tag in processed_hashtags):\n        processed_hashtags = ['#' + tag for tag in processed_hashtags]\n    hashtag_text = ' '.join(processed_hashtags[:10])  # Limit to 10 hashtags\n    \n    # Optimize content for platform\n    if platform == \"Twitter\":\n        max_length = 280 - len(hashtag_text) - 1\n        if len(content_text) > max_length:\n            content_text = content_text[:max_length-3] + \"...\"\n    elif platform == \"Instagram\":\n        max_length = 2200\n        if len(content_text) > max_length:\n            content_text = content_text[:max_length-3] + \"...\"\n    elif platform == \"LinkedIn\":\n        max_length = 3000\n        if len(content_text) > max_length:\n            content_text = content_text[:max_length-3] + \"...\"\n    \n    # Combine content with hashtags\n    final_content = f\"{content_text}\\n\\n{hashtag_text}\" if hashtag_text else content_text\n    \n    # Validate schedule time\n    try:\n        datetime.datetime.strptime(schedule_time, \"%Y-%m-%d %H:%M\")\n        schedule_status = \"Valid\"\n    except:\n        schedule_status = \"Invalid format (use YYYY-MM-DD HH:MM)\"\n    \n    print(f\"Content created for {platform}\")\n    print(f\"Type: {content_type}\")\n    print(f\"Length: {len(final_content)} characters\")\n    print(f\"Hashtags: {len(processed_hashtags)}\")\n    print(f\"Schedule: {schedule_time} ({schedule_status})\")\n    \n    return final_content, platform, content_type, hashtag_text, schedule_status",
            "gui_code": "from PySide6.QtWidgets import QLabel, QTextEdit, QComboBox, QLineEdit, QPushButton, QDateTimeEdit\nfrom PySide6.QtCore import QDateTime\n\nlayout.addWidget(QLabel('Platform:', parent))\nwidgets['platform'] = QComboBox(parent)\nwidgets['platform'].addItems(['Twitter', 'Instagram', 'LinkedIn', 'Facebook'])\nlayout.addWidget(widgets['platform'])\n\nlayout.addWidget(QLabel('Content Type:', parent))\nwidgets['content_type'] = QComboBox(parent)\nwidgets['content_type'].addItems(['Post', 'Story', 'Article', 'Promotion', 'Update'])\nlayout.addWidget(widgets['content_type'])\n\nlayout.addWidget(QLabel('Content:', parent))\nwidgets['content_text'] = QTextEdit(parent)\nwidgets['content_text'].setMinimumHeight(100)\nwidgets['content_text'].setPlaceholderText('Write your content here...')\nlayout.addWidget(widgets['content_text'])\n\nlayout.addWidget(QLabel('Hashtags (comma-separated):', parent))\nwidgets['hashtags'] = QLineEdit(parent)\nwidgets['hashtags'].setPlaceholderText('marketing, social, business')\nlayout.addWidget(widgets['hashtags'])\n\nlayout.addWidget(QLabel('Schedule Time (YYYY-MM-DD HH:MM):', parent))\nwidgets['schedule_time'] = QLineEdit(parent)\nwidgets['schedule_time'].setPlaceholderText('2024-12-25 14:30')\nlayout.addWidget(widgets['schedule_time'])\n\nwidgets['create_btn'] = QPushButton('Create Content', parent)\nlayout.addWidget(widgets['create_btn'])",
            "gui_get_values_code": "def get_values(widgets):\n    return {\n        'content_text': widgets['content_text'].toPlainText(),\n        'platform': widgets['platform'].currentText(),\n        'content_type': widgets['content_type'].currentText(),\n        'hashtags': widgets['hashtags'].text(),\n        'schedule_time': widgets['schedule_time'].text()\n    }\n\ndef set_initial_state(widgets, state):\n    widgets['content_text'].setPlainText(state.get('content_text', ''))\n    widgets['platform'].setCurrentText(state.get('platform', 'Twitter'))\n    widgets['content_type'].setCurrentText(state.get('content_type', 'Post'))\n    widgets['hashtags'].setText(state.get('hashtags', ''))\n    widgets['schedule_time'].setText(state.get('schedule_time', ''))",
            "gui_state": {
                "content_text": "",
                "platform": "Twitter",
                "content_type": "Post",
                "hashtags": "",
                "schedule_time": ""
            },
            "colors": {
                "title": "#007bff",
                "body": "#0056b3"
            }
        },
        {
            "uuid": "engagement-optimizer",
            "title": "Engagement Optimizer",
            "pos": [480, 150],
            "size": [300, 250],
            "code": "import re\nfrom typing import Tuple\n\n@node_entry\ndef optimize_engagement(content: str, platform: str) -> Tuple[int, str, str]:\n    score = 0\n    suggestions = []\n    \n    # Content length scoring\n    content_length = len(content)\n    if platform == \"Twitter\":\n        if 100 <= content_length <= 280:\n            score += 20\n        else:\n            suggestions.append(\"Optimize length for Twitter (100-280 chars)\")\n    elif platform == \"Instagram\":\n        if 150 <= content_length <= 300:\n            score += 20\n        else:\n            suggestions.append(\"Instagram posts perform better with 150-300 characters\")\n    elif platform == \"LinkedIn\":\n        if 200 <= content_length <= 600:\n            score += 20\n        else:\n            suggestions.append(\"LinkedIn content works best with 200-600 characters\")\n    \n    # Hashtag analysis\n    hashtags = re.findall(r'#\\w+', content)\n    if platform == \"Instagram\":\n        if 5 <= len(hashtags) <= 11:\n            score += 15\n        else:\n            suggestions.append(\"Use 5-11 hashtags for Instagram\")\n    elif platform == \"Twitter\":\n        if 1 <= len(hashtags) <= 3:\n            score += 15\n        else:\n            suggestions.append(\"Use 1-3 hashtags for Twitter\")\n    elif platform == \"LinkedIn\":\n        if 1 <= len(hashtags) <= 5:\n            score += 15\n        else:\n            suggestions.append(\"Use 1-5 hashtags for LinkedIn\")\n    \n    # Engagement elements\n    if any(word in content.lower() for word in ['?', 'what', 'how', 'why', 'when']):\n        score += 15\n    else:\n        suggestions.append(\"Add questions to encourage engagement\")\n    \n    if any(word in content.lower() for word in ['share', 'comment', 'like', 'follow', 'subscribe']):\n        score += 10\n    else:\n        suggestions.append(\"Include call-to-action words\")\n    \n    # Readability\n    sentences = re.split(r'[.!?]+', content)\n    avg_sentence_length = sum(len(s.split()) for s in sentences if s.strip()) / max(len([s for s in sentences if s.strip()]), 1)\n    \n    if avg_sentence_length <= 20:\n        score += 10\n    else:\n        suggestions.append(\"Use shorter sentences for better readability\")\n    \n    # Special characters and emojis\n    if re.search(r'[!@#$%^&*()_+{}|:<>?]', content) or any(ord(char) > 127 for char in content):\n        score += 10\n    else:\n        suggestions.append(\"Add emojis or special characters for visual appeal\")\n    \n    # Generate performance prediction\n    if score >= 70:\n        performance = \"High engagement expected\"\n    elif score >= 50:\n        performance = \"Good engagement potential\"\n    elif score >= 30:\n        performance = \"Moderate engagement expected\"\n    else:\n        performance = \"Low engagement predicted\"\n    \n    suggestion_text = '; '.join(suggestions) if suggestions else \"Content optimized for engagement!\"\n    \n    print(f\"\\n=== ENGAGEMENT ANALYSIS ===\")\n    print(f\"Platform: {platform}\")\n    print(f\"Engagement score: {score}/80\")\n    print(f\"Performance prediction: {performance}\")\n    print(f\"Suggestions: {suggestion_text}\")\n    \n    return score, performance, suggestion_text",
            "gui_code": "",
            "gui_get_values_code": "",
            "gui_state": {},
            "colors": {
                "title": "#28a745",
                "body": "#1e7e34"
            }
        },
        {
            "uuid": "schedule-manager",
            "title": "Schedule Manager",
            "pos": [840, 200],
            "size": [280, 250],
            "code": "import datetime\nfrom typing import Tuple\n\n@node_entry\ndef manage_schedule(content: str, platform: str, schedule_time: str, schedule_status: str) -> Tuple[str, str, str]:\n    if schedule_status != \"Valid\":\n        return \"Error\", \"Invalid schedule time format\", \"Failed\"\n    \n    try:\n        scheduled_dt = datetime.datetime.strptime(schedule_time, \"%Y-%m-%d %H:%M\")\n        current_dt = datetime.datetime.now()\n        \n        if scheduled_dt <= current_dt:\n            return \"Error\", \"Cannot schedule in the past\", \"Failed\"\n        \n        # Calculate time until posting\n        time_diff = scheduled_dt - current_dt\n        days = time_diff.days\n        hours, remainder = divmod(time_diff.seconds, 3600)\n        minutes, _ = divmod(remainder, 60)\n        \n        time_until = f\"{days}d {hours}h {minutes}m\"\n        \n        # Determine optimal posting time recommendations\n        hour = scheduled_dt.hour\n        weekday = scheduled_dt.weekday()  # 0=Monday, 6=Sunday\n        \n        optimal_recommendations = []\n        \n        if platform == \"Instagram\":\n            if not (11 <= hour <= 13 or 17 <= hour <= 19):\n                optimal_recommendations.append(\"Instagram: Best times are 11AM-1PM or 5PM-7PM\")\n        elif platform == \"Twitter\":\n            if not (8 <= hour <= 10 or 19 <= hour <= 21):\n                optimal_recommendations.append(\"Twitter: Best times are 8AM-10AM or 7PM-9PM\")\n        elif platform == \"LinkedIn\":\n            if weekday >= 5:  # Weekend\n                optimal_recommendations.append(\"LinkedIn: Weekdays perform better than weekends\")\n            if not (8 <= hour <= 10 or 17 <= hour <= 18):\n                optimal_recommendations.append(\"LinkedIn: Best times are 8AM-10AM or 5PM-6PM\")\n        \n        recommendations = '; '.join(optimal_recommendations) if optimal_recommendations else \"Scheduled at optimal time!\"\n        \n        print(f\"\\n=== SCHEDULE MANAGEMENT ===\")\n        print(f\"Platform: {platform}\")\n        print(f\"Scheduled for: {schedule_time}\")\n        print(f\"Time until posting: {time_until}\")\n        print(f\"Recommendations: {recommendations}\")\n        \n        return \"Scheduled\", time_until, recommendations\n        \n    except Exception as e:\n        error_msg = f\"Scheduling error: {str(e)}\"\n        print(error_msg)\n        return \"Error\", error_msg, \"Failed\"",
            "gui_code": "",
            "gui_get_values_code": "",
            "gui_state": {},
            "colors": {
                "title": "#fd7e14",
                "body": "#e8590c"
            }
        },
        {
            "uuid": "post-dashboard",
            "title": "Social Media Dashboard",
            "pos": [1190, 200],
            "size": [380, 350],
            "code": "from typing import Tuple\n\n@node_entry\ndef create_dashboard(content: str, platform: str, content_type: str, hashtags: str, engagement_score: int, performance_prediction: str, suggestions: str, schedule_status: str, time_until: str, recommendations: str) -> str:\n    dashboard = \"\\n\" + \"=\"*60 + \"\\n\"\n    dashboard += \"           SOCIAL MEDIA POST DASHBOARD\\n\"\n    dashboard += \"=\"*60 + \"\\n\\n\"\n    \n    # Post Overview\n    dashboard += f\"📱 POST OVERVIEW\\n\"\n    dashboard += f\"   Platform: {platform}\\n\"\n    dashboard += f\"   Content Type: {content_type}\\n\"\n    dashboard += f\"   Character Count: {len(content)}\\n\"\n    hashtag_count = len([tag for tag in hashtags.split() if tag.startswith('#')])\n    dashboard += f\"   Hashtags: {hashtag_count}\\n\\n\"\n    \n    # Content Preview\n    dashboard += f\"📝 CONTENT PREVIEW\\n\"\n    preview = content[:150] + \"...\" if len(content) > 150 else content\n    dashboard += f\"   {preview}\\n\\n\"\n    \n    # Engagement Analysis\n    dashboard += f\"📊 ENGAGEMENT ANALYSIS\\n\"\n    dashboard += f\"   Score: {engagement_score}/80\\n\"\n    dashboard += f\"   Prediction: {performance_prediction}\\n\"\n    if suggestions != \"Content optimized for engagement!\":\n        dashboard += f\"   Suggestions: {suggestions}\\n\"\n    dashboard += \"\\n\"\n    \n    # Schedule Information\n    dashboard += f\"⏰ SCHEDULE STATUS\\n\"\n    dashboard += f\"   Status: {schedule_status}\\n\"\n    if schedule_status == \"Scheduled\":\n        dashboard += f\"   Time until posting: {time_until}\\n\"\n        if recommendations != \"Scheduled at optimal time!\":\n            dashboard += f\"   Timing notes: {recommendations}\\n\"\n    elif schedule_status == \"Error\":\n        dashboard += f\"   Issue: {time_until}\\n\"\n    dashboard += \"\\n\"\n    \n    # Action Items\n    dashboard += f\"✅ NEXT STEPS\\n\"\n    if schedule_status == \"Scheduled\":\n        dashboard += f\"   • Content ready for posting\\n\"\n        dashboard += f\"   • Monitor engagement after posting\\n\"\n        dashboard += f\"   • Prepare follow-up content\\n\"\n    else:\n        dashboard += f\"   • Fix scheduling issues\\n\"\n        dashboard += f\"   • Review content optimization\\n\"\n        dashboard += f\"   • Test posting setup\\n\"\n    \n    dashboard += \"\\n\" + \"=\"*60\n    \n    print(dashboard)\n    return dashboard",
            "gui_code": "from PySide6.QtWidgets import QLabel, QTextEdit, QPushButton\nfrom PySide6.QtCore import Qt\nfrom PySide6.QtGui import QFont\n\ntitle_label = QLabel('Social Media Dashboard', parent)\ntitle_font = QFont()\ntitle_font.setPointSize(14)\ntitle_font.setBold(True)\ntitle_label.setFont(title_font)\nlayout.addWidget(title_label)\n\nwidgets['dashboard_display'] = QTextEdit(parent)\nwidgets['dashboard_display'].setMinimumHeight(220)\nwidgets['dashboard_display'].setReadOnly(True)\nwidgets['dashboard_display'].setPlainText('Create content to see dashboard...')\nfont = QFont('Courier New', 9)\nwidgets['dashboard_display'].setFont(font)\nlayout.addWidget(widgets['dashboard_display'])\n\nwidgets['post_now_btn'] = QPushButton('Post Now', parent)\nlayout.addWidget(widgets['post_now_btn'])\n\nwidgets['edit_content_btn'] = QPushButton('Edit Content', parent)\nlayout.addWidget(widgets['edit_content_btn'])\n\nwidgets['duplicate_btn'] = QPushButton('Duplicate for Other Platform', parent)\nlayout.addWidget(widgets['duplicate_btn'])",
            "gui_get_values_code": "def get_values(widgets):\n    return {}\n\ndef set_values(widgets, outputs):\n    dashboard = outputs.get('output_1', 'No dashboard data')\n    widgets['dashboard_display'].setPlainText(dashboard)",
            "gui_state": {},
            "colors": {
                "title": "#6c757d",
                "body": "#545b62"
            }
        }
    ],
    "connections": [
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "exec_out",
            "end_node_uuid": "engagement-optimizer",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_1",
            "end_node_uuid": "engagement-optimizer",
            "end_pin_name": "content"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_2",
            "end_node_uuid": "engagement-optimizer",
            "end_pin_name": "platform"
        },
        {
            "start_node_uuid": "engagement-optimizer",
            "start_pin_name": "exec_out",
            "end_node_uuid": "schedule-manager",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_1",
            "end_node_uuid": "schedule-manager",
            "end_pin_name": "content"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_2",
            "end_node_uuid": "schedule-manager",
            "end_pin_name": "platform"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "schedule_time",
            "end_node_uuid": "schedule-manager",
            "end_pin_name": "schedule_time"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_5",
            "end_node_uuid": "schedule-manager",
            "end_pin_name": "schedule_status"
        },
        {
            "start_node_uuid": "schedule-manager",
            "start_pin_name": "exec_out",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "exec_in"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_1",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "content"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_2",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "platform"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_3",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "content_type"
        },
        {
            "start_node_uuid": "content-creator",
            "start_pin_name": "output_4",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "hashtags"
        },
        {
            "start_node_uuid": "engagement-optimizer",
            "start_pin_name": "output_1",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "engagement_score"
        },
        {
            "start_node_uuid": "engagement-optimizer",
            "start_pin_name": "output_2",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "performance_prediction"
        },
        {
            "start_node_uuid": "engagement-optimizer",
            "start_pin_name": "output_3",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "suggestions"
        },
        {
            "start_node_uuid": "schedule-manager",
            "start_pin_name": "output_1",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "schedule_status"
        },
        {
            "start_node_uuid": "schedule-manager",
            "start_pin_name": "output_2",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "time_until"
        },
        {
            "start_node_uuid": "schedule-manager",
            "start_pin_name": "output_3",
            "end_node_uuid": "post-dashboard",
            "end_pin_name": "recommendations"
        }
    ],
    "requirements": []
}